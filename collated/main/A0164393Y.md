# A0164393Y
###### /java/watodo/logic/commands/MarkCommand.java
``` java

/**
 * Finds and lists all tasks in task manager whose name contains any of the
 * argument keywords. Keyword matching is case sensitive.
 */
public class MarkCommand extends Command {

    public static final String COMMAND_WORD = "mark";
    public static final String MESSAGE_INVALID_TASK = "This task is missing in the task manager.";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Marks the task completed or not completed \n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n" + "Example: " + COMMAND_WORD
            + " task_number completed OR not_completed";

    private final Set<String> keywords;

    public MarkCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        String[] parameters = keywords.toArray(new String[keywords.size()]);
        int filteredTaskListIndex = Integer.parseInt(parameters[0]);

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task editedTask = createEditedTask(taskToEdit, parameters[1]);

```
###### /java/watodo/logic/parser/MarkCommandParser.java
``` java

/**
 * Parses input arguments and creates a new FindCommand object
 */
public class MarkCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the FindCommand
     * and returns an FindCommand object for execution.
     */
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new MarkCommand(keywordSet);
    }

}
```
###### /java/watodo/model/Model.java
``` java

    /**
     * Updates the status
     *
     * @throws TaskNotFoundException
     */
    void markTask(int index, Task editedTask) throws TaskNotFoundException;

    void addTaskUndo(Task task) throws DuplicateTaskException;

    // void updateTaskUndo(Task taskToUpdate, TaskDetails taskDetails, StartTime startTime, EndTime endTime,
    //         Priority priority, String frequency) throws IllegalValueException;

    void deleteTaskUndo(ReadOnlyTask target) throws TaskNotFoundException;

    void clearTaskUndo(ArrayList<Task> tasks) throws TaskNotFoundException;

    void markTaskUndo(int index, Task editedTask) throws TaskNotFoundException;

    LinkedList<UndoInfo> getUndoStack();

    void addToUndoStack(int strCmdId, String currentFilePath, Task... tasks);

}
```
###### /java/watodo/model/ModelManager.java
``` java

    @Override
    public void markTask(int index, Task editedTask) throws TaskNotFoundException {
        taskManager.markTask(index, editedTask);
        indicateTaskManagerChanged();
    }

```
###### /java/watodo/model/task/Status.java
``` java

/**
 * Represents a Task's status in the task manager. Guarantees: transaction
 * between states are doable.
 */
public class Status {

    private static final String NOT_COMPLETED_MESSAGE = "(Task is incomplete)";
    private static final String COMPLETED_MESSAGE = "(Task is completed)";
    private static final String UNDEFINED_STATUS_MESSAGE = "An internal error has occured. Status not readable.";
    public final int status;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException
     *             if given name string is invalid.
     */
    public Status(int status) {
        this.status = status;
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public boolean isValidTransaction(int status) {
        if (this.status == status) {
            return false;
        } else {
            return true;
        }
    }

    @Override
    public String toString() {
        if (this.status == 0) {
            return NOT_COMPLETED_MESSAGE;
        } else if (this.status == 1) {
            return COMPLETED_MESSAGE;
        }
        return UNDEFINED_STATUS_MESSAGE;
    }

}
```
###### /java/watodo/model/task/UniqueTaskList.java
``` java

    /**
     * Marks a task.
     *
     * @throws TaskNotFoundException
     *             if the task to mark is missing in the list.
     */
    public void markTask(int index, Task editedTask) throws TaskNotFoundException {
        assert editedTask != null;

        if (!internalList.contains(editedTask)) {
            throw new TaskNotFoundException();
        }

        Task taskToUpdate = internalList.get(index);

        taskToUpdate.setStatus(editedTask.getStatus());
        internalList.set(index, taskToUpdate);
    }

    public void setTasks(UniqueTaskList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setTasks(List<? extends ReadOnlyTask> tasks) throws DuplicateTaskException {
        final UniqueTaskList replacement = new UniqueTaskList();
        for (final ReadOnlyTask task : tasks) {
            replacement.add(new Task(task));
        }
        setTasks(replacement);
    }

    public UnmodifiableObservableList<Task> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

```
###### /java/watodo/model/TaskManager.java
``` java

    /**
     * Marks the status of the task given.
     *
     * @throws TaskNotFoundException
     * @throws DuplicateTaskException
     */

    public void markTask(int index, Task editedTask) throws TaskNotFoundException {
        tasks.markTask(index, editedTask);
    }

    /**
     * Updates the task in the list at position {@code index} with {@code editedReadOnlyTask}.
     * {@code TaskManager}'s tag list will be updated with the tags of {@code editedReadOnlyTask}.
     * @see #syncMasterTagListWith(Task)
     *
     * @throws DuplicateTaskException if updating the task's details causes the task to be equivalent to
     *      another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(int index, ReadOnlyTask editedReadOnlyTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedReadOnlyTask != null;

        Task editedTask = new Task(editedReadOnlyTask);
        syncMasterTagListWith(editedTask);
        // TODO: the tags master list will be updated even though the below line fails.
        // This can cause the tags master list to have additional tags that are not tagged to any task
        // in the task list.
        tasks.updateTask(index, editedTask);
    }

    /**
     * Ensures that every tag in this task:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     */
    private void syncMasterTagListWith(Task task) {
        final UniqueTagList taskTags = task.getTags();
        tags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        // used for checking task tag references
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        tags.forEach(tag -> masterTagObjects.put(tag, tag));

        // Rebuild the list of task tags to point to the relevant tags in the master tag list.
        final Set<Tag> correctTagReferences = new HashSet<>();
        taskTags.forEach(tag -> correctTagReferences.add(masterTagObjects.get(tag)));
        task.setTags(new UniqueTagList(correctTagReferences));
    }

    /**
     * Ensures that every tag in these tasks:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     *  @see #syncMasterTagListWith(Task)
     */
    private void syncMasterTagListWith(UniqueTaskList tasks) {
        tasks.forEach(this::syncMasterTagListWith);
    }

    public boolean removeTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.remove(key)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }

//// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

    // util methods

    @Override
    public String toString() {
        return tasks.asObservableList().size() + " tasks, " + tags.asObservableList().size() +  " tags";
        // TODO: refine later
    }

    @Override
    public ObservableList<ReadOnlyTask> getTaskList() {
        return new UnmodifiableObservableList<>(tasks.asObservableList());
    }

    @Override
    public ObservableList<Tag> getTagList() {
        return new UnmodifiableObservableList<>(tags.asObservableList());
    }

```
